(defvar creatures nil)
(defvar turn-order nil)
(defvar current-turn 0)

(defun test-attack (entity &key (target-point '(0 0)))
  (let* ((x (car target-point))
	 (y (cadr target-point))
	 (object (cond ((string= (aref main-map y x) (cadr (assoc 'tree-trunk symbols-list)))
			"tree")
		       ((string= (aref main-map y x) (cadr (assoc 'water symbols-list)))
			"water")
		       ((string= (aref main-map y x) (cadr (assoc 'wall symbols-list)))
			"wall")
		       ((string= (aref main-map y x) (cadr (assoc 'floor symbols-list)))
			"air"))))
    (if (and (not (creature-p entity))
	     (not (eq (aref enemy-array y x) 0)))
	(calculate-entity-attack entity :target-point (list x y))
	(if (creature-p entity)
	    (calculate-entity-attack entity)
	    (if (eq (aref item-array y x) 0)
		(push-message (concatenate 'string "You strike the " object " for no apparent reason."))
		(push-message (concatenate 'string "You're attacking the " (item-name (aref item-array y x)) "!?!? This is the worst thing since my son."))
		))
	)))

(defun calculate-entity-attack (entity &key target-point)
  (let* ((target (if (player-character-p entity)
		     (aref enemy-array (cadr target-point) (car target-point))
		     player))
	 (attack-power (+ (entity-attack entity) (entity-attack-mod entity) (if (item-p (entity-weapon entity))
										(item-attack (entity-weapon entity))
										2)))
	 (defense-power (+ (entity-defense target) (entity-defense-mod target) (if (item-p (entity-armor target))
										   (item-defense (entity-armor target))
										   0)))
	 (attack-chance (if (< (+ (entity-dodge target) (entity-dodge-mod target)) (+ (random 90) 10))
			    t
			    nil))
	 )
    (if attack-chance
	(if (> (- attack-power defense-power) 0)
	    (if (player-character-p entity)
		(progn (decrease-hp (aref enemy-array (cadr target-point) (car target-point)) (- attack-power defense-power))
		       (push-message (concatenate 'string "You hit the " (entity-name target) " for " (write-to-string (- attack-power defense-power))))
		       )
		(decrease-hp player (- attack-power defense-power)))
	    (push-message "The attack bounced off!")
	    )
	(push-message "Swing and a miss.")
	)
    (if (entity-dead target)
	(if (not (player-character-p target))
	    (progn (add-xp player (entity-xp target))
		   (setf creatures (remove (aref enemy-array (cadr target-point) (car target-point)) creatures))
		   (setf (aref enemy-array (cadr target-point) (car target-point)) 0)
		   )
	;;;;(if (not (item-p target))
	;;;;    (setf state 'game-over)
	;;;;    (destroy-item target-point))
	    ))
    )
  )

(defun test-ranged-attack (entity &key target-point)
  ;;;;create a line from entity-x, entity-y to tp-x, tp-y
  ;;;;test each point for an entity
  ;;;;if an entity is hit, then take away hp
  (let ((line (list (- (car target-point) (cadr (assoc :x (entity-position entity))))
		    (- (cadr target-point) (cadr (assoc :y (entity-position entity))))))
	)
    ;;;;if x is bigger than y, then loop x by number, otherwise, loop y by number
    (path-search (list (cadr (assoc :x (entity-position entity))) 
		       (cadr (assoc :y (entity-position entity))))
		 target-point
		 line
		 )
    )
  #|  (if (> (abs (car line)) (abs (cadr line)))
  (test-by-x)
  (test-by-y))|#
  )

#|

(defvar main-map nil)
(defvar item-array nil)
(defvar enemy-array nil)
(load "test-map.cl")
test-points
(load "engine/symbols.cl")
(defvar start-point '(60 70))
(defvar target-points '((70 80)
         (70 60)
         (50 80)
         (50 60)
         (60 80)
         (60 60)
         (50 70)
         (70 70)
         (65 80)
         (65 60)
         (70 75)
         (70 65)
         (40 80)
         (60 20)
         (70 20)))

(defvar points nil)
(defvar line nil)
(defvar end-point)

(defun test ()
  (loop for n below (length target-points)
    do (setf end-point (nth n target-points))
       (setf line (list (- (car end-point) (car start-point)) (- (cadr end-point) (cadr start-point))))
       (path-search start-point end-point line)
       (fresh-line)
       (setf points nil)
       ))


(defun results () 
  (loop for n below (length target-points)
     do (setf end-point (nth n target-points))
       (setf line (list (- (car end-point) (car start-point)) (- (cadr end-point) (cadr start-point))))
       (path-search start-point end-point line)
       (fresh-line)
       (loop for y below 100
	  do (loop for x below 100
		do (if (loop for a below (length points)
			  do (if (and (eq x (car (nth a points)))
				      (eq y (cadr (nth a points))))
				 (return t)))
		       (princ "#")
		       (princ (aref main-map y x)))) (fresh-line))
       (setf points nil)))
|#

(defun path-search (start-point target-point line)
  ;;;;start-x end-x, start-y end-y
  (let* ((end-x 0)
	 (end-y 0)
	 (is-bigger (if (eq (car line) 0)
			'y
			(if (eq (cadr line) 0)
			    'x
			    (if (> (car line) (cadr line))
				'x			
				'y))))
	 (start-x (car start-point))
	 (start-y (cadr start-point))
	 (s-x (if (eq (car line) 0)
		  1
		  (car line)))
	 (s-y (if (eq (cadr line) 0)
		  1
		  (cadr line)))
	 (slope (if (and (eq is-bigger 'x)
			 (or (and (not (eq (car line) 0))
				  (not (eq (cadr line) 0)))
			     (> (abs (car line)) (abs (cadr line)))))
		    (round (/ s-x s-y))
		    (if (or (and (not (eq (car line) 0))
				 (not (eq (cadr line) 0)))
			    (> (abs (cadr line)) (abs (car line))))
			(round (/ s-y s-x))
			(if (eq (car line) 0)
			    (cadr line)
			    (if (eq (cadr line) 0)
				(car line))))))
	 (target-aquired nil)
	 )
    (print is-bigger)
    (print slope)
    (print s-x) (print s-y)
#|    (if (and (or (< (car line) 0)
		 (< (cadr line) 0))
	     (not (or (eq (car line) 0)
		      (eq (cadr line) 0))))
    (setf slope (* slope -1)))|#
    (if (and (< s-y 0)
	     (< s-x 0))
	(setf slope (* slope -1)))
    (if (eq slope 0)
	(if (and (not (eq s-x 0))
		 (not (eq s-y 0)))
	    (if (> (abs s-x) (abs s-y))
		(setf slope (round (/ s-x s-y)))
		(setf slope (round (/ s-y s-x))))
	    (setf slope 1)))
    (print slope)
    (setf end-y (+ start-y (if (> s-y 0)
			       (abs slope)
			       slope))
	  end-x (+ start-x (if (> s-x 0)
			       (abs slope)
			       slope)))
    (if (eq is-bigger 'x)
	(progn (if (>= (car target-point) (car start-point))
		   (if (>= (cadr target-point) (cadr start-point))
		       (loop for y from start-y to (cadr target-point)
			  do (loop for x from start-x to end-x until (> x (car target-point))
				do (if (not target-aquired)
				       (if (test-terrain x y)
					   (setf target-aquired (list 'terrain x y))
					   (if (test-creatures x y)
					       (setf target-aquired (list 'creature x y))
					       )
					   )
			       ;;;;test projectile collision with terrain map and enemy map
				       )
				  (print (concatenate 'string "x: "(write-to-string x) " y:" (write-to-string y)))
				  (push (list x y) points)
				  )
			    (incf start-x (abs slope))
			    (incf end-x (abs slope))
			    )
		       (loop for x from start-x to (car target-point)
			  do (loop for y from start-y downto end-y until (< y (cadr target-point))
				do (if (not target-aquired)
				       (if (test-terrain x y)
					   (setf target-aquired (list 'terrain x y))
					   (if (test-creatures x y)
					       (setf target-aquired (list 'creature x y))
					       )
					   )
			       ;;;;test projectile collision with terrain map and enemy map
				       )
				  (print (concatenate 'string "x: "(write-to-string x) " y:" (write-to-string y)))
				  (push (list x y) points)
				  )
			    (incf start-y slope)
			    (incf end-y slope)
			    ))
		   (if (>= (cadr target-point) (cadr start-point))
		       (loop for y from start-y to (cadr target-point)
			  do (loop for x from start-x downto end-x until (< x (car target-point))
				do (if (not target-aquired)
				       (if (test-terrain x y)
					   (setf target-aquired (list 'terrain x y))
					   (if (test-creatures x y)
					       (setf target-aquired (list 'creature x y))
					       )
					   )
				       )
				  (print (concatenate 'string "x: "(write-to-string x) " y:" (write-to-string y)))
				  (push (list x y) points)
				  )
			    (incf start-x slope)
			    (incf end-x slope)
			    )
		       (loop for x from start-x downto (car target-point)
			  do (loop for y from start-y downto end-y until (< y (cadr target-point))
				do (if (not target-aquired)
				       (if (test-terrain x y)
					   (setf target-aquired (list 'terrain x y))
					   (if (test-creatures x y)
					       (setf target-aquired (list 'creature x y))
					       )
					   )
			       ;;;;test projectile collision with terrain map and enemy map
				       )
				  (print (concatenate 'string "x: "(write-to-string x) " y:" (write-to-string y)))
				  (push (list x y) points)
				  )
			    (incf start-y slope)
			    (incf end-y slope)
			    ))
		   ))
	(progn (if (>= (cadr target-point) (cadr start-point))
		   (if (>= (car target-point) (car start-point))
		       (loop for x from start-x to (car target-point)
			  do (loop for y from start-y to end-y until (> y (cadr target-point))
				do (if (not target-aquired)
				       (if (test-terrain x y)
					   (setf target-aquired (list 'terrain x y))
					   (if (test-creatures x y)
					       (setf target-aquired (list 'creature x y))
					       )
					   )
			       ;;;;test projectile collision with terrain map and enemy map
				       )
				  (print (concatenate 'string "x: "(write-to-string x) " y:" (write-to-string y)))
				  (push (list x y) points)
				  )
			    (incf start-y (abs slope))
			    (incf end-y (abs slope))
			    )
		       (loop for y from start-y to (cadr target-point)
			  do (loop for x from start-x downto end-x until (< x (car target-point))
				do (if (not target-aquired)
				       (if (test-terrain x y)
					   (setf target-aquired (list 'terrain x y))
					   (if (test-creatures x y)
					       (setf target-aquired (list 'creature x y))
					       )
					   )
			       ;;;;test projectile collision with terrain map and enemy map
				       )
				  (print (concatenate 'string "x: "(write-to-string x) " y:" (write-to-string y)))
				  (push (list x y) points)
				  )
			    (incf start-x slope)
			    (incf end-x slope)
			    ))
		   (if (>= (car target-point) (car start-point))
		       (loop for x from start-x to (car target-point)
			  do (loop for y from start-y downto end-y until (< y (cadr target-point))
				do (if (not target-aquired)
				       (if (test-terrain x y)
					   (setf target-aquired (list 'terrain x y))
					   (if (test-creatures x y)
					       (setf target-aquired (list 'creature x y))
					       )
					   )
			       ;;;;test projectile collision with terrain map and enemy map
				       )
				  (print (concatenate 'string "x: "(write-to-string x) " y:" (write-to-string y)))
				  (push (list x y) points)
				  )
			    (incf start-y slope)
			    (incf end-y slope)
			    )
		       (loop for y from start-y downto (cadr target-point)
			  do (loop for x from start-x downto end-x until (< x (car target-point))
				do (if (not target-aquired)
				       (if (test-terrain x y)
					   (setf target-aquired (list 'terrain x y))
					   (if (test-creatures x y)
					       (setf target-aquired (list 'creature x y))
					       )
					   )
			       ;;;;test projectile collision with terrain map and enemy map
				       )
				  (print (concatenate 'string "x: "(write-to-string x) " y:" (write-to-string y)))
				  (push (list x y) points)
				  )
			    (incf start-x slope)
			    (incf end-x slope)
			    ))
		   )))
    target-aquired))

(defun test-terrain (x y)
  (cond ((string= (aref main-map y x) (cadr (assoc 'tree-trunk symbols-list)))
	 t)
	((string= (aref main-map y x) (cadr (assoc 'wall symbols-list)))
	 t))
  )

(defun test-creatures (x y)
  (if (not (eq (aref enemy-array y x) 0))
      t
      )
  )

(defmacro agility-test (obj1 obj2)
  `(let ((a1 (entity-agility ,obj1))
	 (a2 (entity-agility ,obj2)))
     (if (> a1 a2)
	 t)))

(defun set-turn-order ()
  (let* ((test (append player creatures))
	 (temp-order (list (nth 0 test))))
    (setf turn-order (list (list 'm 0)))
    (loop for n from 1 to (1- (length test))
       do (loop for y below (length turn-order)
	     do (let ((obj (if (creature-p (nth n test))
			       (list 'm n)
			       (list 'p (- n (length creatures))))))
		  (if (agility-test (nth n test) (nth y temp-order))
		      (if (eq y 0)
			  (return (progn (push obj turn-order)
					 (push (nth n test) temp-order)
					 (princ "fastest") (fresh-line)))
			  (return (progn (push (nth n test) (cdr (nthcdr (1- y) temp-order)))
					 (push obj (cdr (nthcdr (1- y) turn-order)))
					 (princ "Not as Fast, but still fucking fast") (fresh-line))))
		      (if (eq y (1- (length turn-order)))
			  (return (progn (setf temp-order (append temp-order (list (nth n test))))
					 (setf turn-order (append turn-order (list obj)))
					 (princ "slower than my brother") (fresh-line)))
			  ))))
	 (princ temp-order) (princ "        ") (princ turn-order) (fresh-line))))
;;;;Well, looks a bit Cish now, but fuck it. I love this. It makes my ego hard. Did it all by myself, without needing to ask anybody for help.

(defun entity-dead (entity)
  (<= (entity-hp entity) 0))
